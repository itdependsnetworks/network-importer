#!/usr/bin/env python

"""
(c) 2019 Network To Code

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import argparse
import sys
import os
import json
import yaml
import logging
import random  # noqa: F401
import pdb
import re

from collections import defaultdict

import pandas as pd

from pybatfish.client.commands import *

# noinspection PyUnresolvedReferences
from pybatfish.datamodel import Edge, Interface
from pybatfish.client.session import Session
from pybatfish.datamodel.answer import TableAnswer
from pybatfish.datamodel.flow import HeaderConstraints, PathConstraints  # noqa: F401
from pybatfish.question import bfq, list_questions, load_questions  # noqa: F401
from pybatfish.util import get_html

from termcolor import colored

import pynetbox
import requests

from nornir import InitNornir

import network_importer
from network_importer.model import (
    NetworkImporterDevice,
    NetworkImporterInterface,
    NetworkImporterSite,
    NetworkImporterVlan,
)

from jinja2 import Template, Environment, FileSystemLoader

__author__ = "Damien Garros <damien.garros@networktocode.com>"

logger = logging.getLogger("network-importer")

PRESENT = colored("PRESENT", "green")
ABSENT = colored("ABSENT", "yellow")


class CustomFormatter(
    argparse.RawDescriptionHelpFormatter, argparse.ArgumentDefaultsHelpFormatter
):
    pass


class NetboxConfig():
    def __init__(self, address, token):
        self.address = address
        self.token = token

        self._validate_params()
        self._test_connection()

    def _validate_params(self):
        if not self.address:
            raise Exception("Please provide the location of the netbox server using the environment variables NETBOX_ADDRESS ")
        elif not self.token:
            raise Exception("Please provide a valid netbox token using the environment variables NETBOX_TOKEN ")

    def _test_connection(self):
        nb = pynetbox.api(self.address, token=self.token)
        try:
            nb.dcim.devices.get(name="csr1")
        except requests.exceptions.ConnectionError:
            logger.critical(
                "Unable to connect to the netbox server, please check the NETBOX_ADDRESS env variable"
            )
            sys.exit(1)
        except pynetbox.core.query.RequestError as e:
            print(e)
            logger.critical(
                "Unable to complete a query to the netbox server, please check the env variables"
            )
            sys.exit(1)
        except requests.exceptions.RequestException as e:
            logger.critical(
                "Unable to connect to the netbox server, please check the address and the token"
            )
            print(e)
            sys.exit(1)


def parse_args(args=sys.argv[1:]):
    """Parse arguments."""
    parser = argparse.ArgumentParser(
        description=sys.modules[__name__].__doc__, formatter_class=CustomFormatter
    )

    parser.add_argument(
        "--configs",
        metavar="DIR",
        type=str,
        help="Directory where to find the configurations (in batfish format)",
        default=False,
    )

    parser.add_argument(
        "--output",
        metavar="DIR",
        type=str,
        help="Directory where to save the device variables",
        default="host_vars",
    )

    parser.add_argument(
        "--limit", type=str, help="limit the execution on a specific device"
    )

    parser.add_argument("--inventory", help="Inventory file", type=str, default=False)

    g = parser.add_mutually_exclusive_group(required=True)
    g.add_argument(
        "--check",
        action="store_true",
        default=False,
        help="Display what are the differences but do not save them",
    )

    g.add_argument(
        "--apply", action="store_true", default=False, help="Save changes in Backend"
    )

    return parser.parse_args(args)

find_digit = re.compile("\D?(\d+)\D?")
def sort_by_digits(if_name):
    return tuple(map(int, find_digit.findall(if_name)))


def jinja_filter_toyaml_list(value):
    return yaml.dump(value, default_flow_style=None)


def jinja_filter_toyaml_dict(value):
    return yaml.dump(value, default_flow_style=False)


def main():

    module_path = os.path.dirname(network_importer.__file__)
    TPL_DIR = f"{module_path}/templates/"

    options = parse_args()

    ## Check if all environment variables have been provided
    BATFISH_ADDR = os.environ.get("BATFISH_ADDRESS", "localhost")

    ## Setup logging
    logging.getLogger("pybatfish").setLevel(logging.ERROR)
    logging.basicConfig(stream=sys.stdout)

    logger.setLevel(logging.INFO)

    # ------------------------------------------------------------
    # Initialize Batfish (TODO If configs have been provided)
    # ------------------------------------------------------------
    NETWORK_NAME = "network-importer"
    SNAPSHOT_NAME = "network-importer"
    SNAPSHOT_PATH = options.configs

    bf_session.host = BATFISH_ADDR

    try:
        load_questions()
    except requests.exceptions.ConnectionError:
        logger.critical(
            f"Unable to connect to the batfish service ({BATFISH_ADDR}) .. please check if it's running"
        )
        sys.exit(1)

    logger.info("Importing and analyzing all configurations ... ")

    bf_set_network(NETWORK_NAME)
    bf_init_snapshot(SNAPSHOT_PATH, name=SNAPSHOT_NAME, overwrite=True)

    batfish_session = Session()
    batfish_session.set_network(NETWORK_NAME)
    batfish_session.set_snapshot(SNAPSHOT_NAME)

    # ------------------------------------------------------------
    # Initialize Netbox, and pull existing devices
    # ------------------------------------------------------------
    nb_config = NetboxConfig(os.environ.get("NETBOX_ADDRESS"), os.environ.get("NETBOX_TOKEN"))
    nb = pynetbox.api(nb_config.address, token=nb_config.token)
    # TODO manage exception for Nornir and the validity of the inventory file
    if options.inventory:
        nr = InitNornir(
            core={"num_workers": 2},
            logging={"enabled": False},
            inventory={
                "plugin": "nornir.plugins.inventory.ansible.AnsibleInventory",
                "options": {"hostsfile": options.inventory},
            },
        )

    sites = dict()
    devs = dict()

    # TODO Add check to only create directory if required
    if options.apply and not os.path.exists(f"{options.output}"):
        os.makedirs(f"{options.output}")
        logger.debug(f"Directory {options.output} was missing, created it")

    # ------------------------------------------------------------
    # Build inventory
    #  - if only batfish
    #      devices are expected to existing netbox already
    #      Fail if device is not present
    #  - if Nornir and Batfish
    #      if the device is not present in netbox,
    #          check if site, model and role info are present
    #          try to create the device
    #      check if the site is defined in nornir
    #
    #  - If only Nornir
    #     Not supported Yet
    # ------------------------------------------------------------

    for bf_dev in bfq.nodeProperties().answer().frame().itertuples():

        dev = NetworkImporterDevice(
            name=bf_dev.Hostname, bf=bf_dev, nb=nb, vendor=bf_dev.Vendor_Family.lower()
        )

        if options.limit and dev.name != options.limit:
            continue

        logger.info(f"Processing {dev.name} data, local and remote .. ")

        if dev.exist_remote:
            ## Check if site and vlans information are already in cache
            if dev.remote.site.slug not in sites.keys():
                site = NetworkImporterSite(name=dev.remote.site.slug, nb=nb)
                sites[site.name] = site
                dev.site = site
                logger.debug(f"Created site {site.name}")

            else:
                dev.site = sites[dev.remote.site.slug]

        if options.inventory and bf_dev.Hostname in nr.inventory.hosts.keys():
            dev.nr = nr.inventory.hosts[dev.name]

            # Check if we have everything to create the device in netbox
            # Shoudl probably move this logic inside the object
            if not dev.exist_remote:
                dev.platform = dev.nr.get("platform")
                dev.model = dev.nr.get("model")
                dev.role = dev.nr.get("role")

                # TODO impriove hte site management
                # Should check if already exist first
                if dev.nr.get("site") not in sites.keys():
                    site = NetworkImporterSite(name=dev.nr.get("site"), nb=nb)
                    dev.site = site
                    sites[site.name] = site

                if dev.site == None or dev.model == None or dev.role == None:
                    logger.warning(
                        f"{dev.name} is not present in netbox and some information are missing to create it .. SKIPPING"
                    )
                    continue

                # TODO move this section inside the NI Device Object
                if options.apply:
                    try:
                        dev.remote = nb.dcim.devices.create(
                            name=dev.name,
                            device_type={"slug": dev.model},
                            device_role={"slug": dev.role},
                            site={"slug": dev.site.name},
                        )
                        logger.info(
                            f"{dev.name} created in Netbox (site: {dev.site.name}, Role: {dev.role})"
                        )

                    except:
                        logger.error(
                            f"Unable to create the device {dev.name} in netbox, please check that 'site', 'model' and 'role' are properly defined in the inventory and are matching existing resources in netbox .. SKIPPING"
                        )
                        continue

        elif options.inventory and not dev.exist_remote:
            logger.error(
                f"The device {dev.name} doesn't exist in netbox and no inventory have been provided ... SKIPPING "
            )
            continue

        bf_ints = bfq.interfaceProperties(nodes=dev.name).answer()

        for bf_intf in bf_ints.frame().itertuples():
            found_intf = False

            intf_name = bf_intf.Interface.interface

            intf = NetworkImporterInterface(
                name=intf_name,
                device_name=dev.name,
                speed=bf_intf.Speed,
                mtu=bf_intf.MTU,
                switchport_mode=bf_intf.Switchport_Mode,
            )

            intf.bf = bf_intf
            dev.add_interface(intf)

            for prfx in bf_intf.All_Prefixes:
                dev.add_ip(intf_name=intf.name, address=prfx)

            # Updating Interface properly
            # logger.info(f"{dev.name} - Interface {bf_intf.Interface.interface} configured in access mode, vlan {bf_intf.Access_VLAN}")
            # ## Update interface with vlan

            bf_vlans = bfq.switchedVlanProperties(nodes=dev.name).answer()
            for vlan in bf_vlans.frame().itertuples():
                if vlan.VLAN_ID not in dev.site.vlans.keys():
                    dev.site.add_vlan(
                        NetworkImporterVlan(
                            name=f"vlan-{vlan.VLAN_ID}", vid=vlan.VLAN_ID
                        )
                    )

        devs[dev.name] = dev

        if options.apply:

            # Save device variables in file
            if not os.path.exists(f"{options.output}/{dev.name}"):
                os.makedirs(f"{options.output}/{dev.name}")
                logger.debug(
                    f"Directory {options.output}/{dev.name} was missing, created it"
                )

            dev_facts = batfish_session.extract_facts(nodes=dev.name)["nodes"][dev.name]

            # pdb.set_trace()
            # Load Jinja2 template
            # env = Environment(
            #     loader=FileSystemLoader(TPL_DIR), trim_blocks=True, lstrip_blocks=True
            # )
            # env.filters["to_yaml_list"] = jinja_filter_toyaml_list
            # env.filters["to_yaml_dict"] = jinja_filter_toyaml_dict
            # template = env.get_template("hostvars.j2")
            # hostvars_str = template.render(dev_facts)

            with open(
                f"{options.output}/{dev.name}/network_importer.yaml", "w"
            ) as out_file:
                out_file.write( yaml.dump(dev_facts, default_flow_style=False))
                # out_file.write( hostvars_str)
                logger.debug(
                    f"{dev.name} - Host variables saved in {options.output}/{dev.name}/network_importer.yaml"
                )

    # ------------------------------------------------------------------------------------
    # Update Remote if apply is enabled
    #   First create all vlans per site to ensure they exist
    # ------------------------------------------------------------------------------------
    if options.apply:
        for site in sites.values():
            site.update_remote()

        for dev in devs.values():
            dev.update_remote()

    # ------------------------------------------------------------------------------------
    # Print on Screen all devices, interfaces and IPs and how their current status compare to remote
    #   Currently we only track PRESENT and ABSENT but we should also track DIFF and UPDATED
    #   This print function might be better off in the device object ...
    # ------------------------------------------------------------------------------------
    for site in sites.values():
        print(f" -- Site {site.name} -- ")
        for vlan in site.vlans.values():
            if vlan.exist_remote:
                print("{:4}{:32}{:12}".format("", f"Vlan {vlan.vid}", PRESENT))
            else:
                print("{:4}{:32}{:12}".format("", f"Vlan {vlan.vid}", ABSENT))

        print("  ")

        for dev in devs.values():
            if dev.site.name != site.name:
                continue
            if dev.exist_remote:
                print("{:4}{:42}{:12}".format("", f"Device {dev.name}", PRESENT))
            else:
                print("{:4}{:42}{:12}".format("", f"Device {dev.name}", ABSENT))

            for intf_name in sorted(dev.interfaces.keys(), key=sort_by_digits):
                intf = dev.interfaces[intf_name]
                if intf.exist_remote:
                    print("{:8}{:38}{:12}".format("", f"{intf.name}", PRESENT))
                else:
                    print("{:8}{:38}{:12}".format("", f"{intf.name}", ABSENT))

                for ip in intf.ips.values():
                    if ip.exist_remote:
                        print("{:12}{:34}{:12}".format("", f"{ip.address}", PRESENT))
                    else:
                        print("{:12}{:34}{:12}".format("", f"{ip.address}", ABSENT))
            print("  ")

    # -------------------------------------------------------------
    # Build cabling
    #   Currently we are only getting the information from the L3 EDGE in Batfish
    #   We need to pull LLDP data as well using Nornir to complement that
    # -------------------------------------------------------------
    p2p_links = bfq.layer3Edges().answer()

    already_connected_links = {}

    for link in p2p_links.frame().itertuples():
        try:
            local_host = link.Interface.hostname
            local_intf = re.sub("\.\d+$", "", link.Interface.interface)
            remote_host = link.Remote_Interface.hostname
            remote_intf = re.sub("\.\d+$", "", link.Remote_Interface.interface)

            unique_id = "_".join(
                sorted([f"{local_host}:{local_intf}", f"{remote_host}:{remote_intf}"])
            )
            if unique_id in already_connected_links:
                logger.debug(f"Link {unique_id} already connected .. SKIPPING")
                continue

            if local_host not in devs.keys():
                logger.debug(f"LINK: {local_host} not present in devices list")
                continue
            elif remote_host not in devs.keys():
                logger.debug(f"LINK: {remote_host} not present in devices list")
                continue

            if local_intf not in devs[local_host].interfaces.keys():
                logger.warning(
                    f"LINK: {local_host}:{local_intf} not present in interfaces list"
                )
                continue
            elif remote_intf not in devs[remote_host].interfaces.keys():
                logger.warning(
                    f"LINK: {remote_host}:{remote_intf} not present in interfaces list"
                )
                continue

            if not devs[local_host].interfaces[local_intf].remote:
                logger.warning(
                    f"LINK: {local_host}:{local_intf} remote object not present SKIPPING"
                )
                continue
            elif not devs[remote_host].interfaces[remote_intf].remote:
                logger.warning(
                    f"LINK: {remote_host}:{remote_intf} remote object not present SKIPPING"
                )
                continue

            ## Check if both interfaces are already connected or not

            if devs[local_host].interfaces[local_intf].remote.connection_status:
                remote_host_reported = (
                    devs[local_host]
                    .interfaces[local_intf]
                    .remote.connected_endpoint.device.name
                )
                remote_int_reported = (
                    devs[local_host]
                    .interfaces[local_intf]
                    .remote.connected_endpoint.name
                )

                if remote_host_reported != remote_host:
                    logger.warning(
                        f"LINK: {local_host}:{local_intf} is already connected but to a different device ({remote_host_reported} vs {remote_host})"
                    )
                elif (
                    remote_host_reported == remote_host
                    and remote_intf != remote_int_reported
                ):
                    logger.warning(
                        f"LINK: {local_host}:{local_intf} is already connected but to a different interface ({remote_int_reported} vs {remote_intf})"
                    )

                continue

            elif devs[remote_host].interfaces[remote_intf].remote.connection_status:
                local_host_reported = (
                    devs[remote_host]
                    .interfaces[remote_intf]
                    .remote.connected_endpoint.device.name
                )
                local_int_reported = (
                    devs[remote_host]
                    .interfaces[remote_intf]
                    .remote.connected_endpoint.name
                )

                if local_host_reported != local_host:
                    logger.warning(
                        f"LINK: {remote_host}:{remote_intf} is already connected but to a different device ({local_host_reported} vs {local_host})"
                    )
                elif (
                    local_host_reported == local_host
                    and local_intf != local_int_reported
                ):
                    logger.warning(
                        f"LINK:  {remote_host}:{remote_intf} is already connected but to a different interface ({local_int_reported} vs {local_intf})"
                    )

                continue

            else:
                logger.info(
                    f"Link not present will create it in netbox ({local_host}:{local_intf} || {remote_host}:{remote_intf}) "
                )
                link = nb.dcim.cables.create(
                    termination_a_type="dcim.interface",
                    termination_a_id=devs[local_host].interfaces[local_intf].remote.id,
                    termination_b_type="dcim.interface",
                    termination_b_id=devs[remote_host]
                    .interfaces[remote_intf]
                    .remote.id,
                )

                already_connected_links[unique_id] = 1
        except:
            logger.warning(
                f"Something went wrong while processing the link {unique_id}",
                exc_info=True,
            )

    # pdb.set_trace()


if __name__ == "__main__":
    main()
